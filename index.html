<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Caring Tap Game</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height:100%; margin:0; padding:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#000; overflow:hidden; }
    #frame { width:100vw; height:100vh; position:relative; overflow:hidden; background:#120818; }
    #bgLayer { position:absolute; inset:0; z-index:0; background:linear-gradient(135deg,#1a0a2e 0%,#3d0a1a 50%,#0a1a2e 100%); background-position:center; background-size:cover; background-repeat:no-repeat; pointer-events:none; }
    #bgLayer img { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:none; }
    #bgTint  { position:absolute; inset:0; z-index:1; background:rgba(10,0,8,0.35); pointer-events:none; }
    #c { position:absolute; inset:0; z-index:2; width:100%; height:100%; display:block; pointer-events:none; }
    #c.active { pointer-events:auto; }

    .hud {
      position:absolute;
      right: -38vh; top: 50%;
      width: 100vh;
      transform: translateY(-50%) rotate(90deg);
      transform-origin: center center;
      display:flex; justify-content:space-between;
      gap:16px; z-index:3; pointer-events:none;
      padding: 0 20px;
    }
    .pill { padding:14px 20px; border-radius:16px; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.22); color:#fff; font-weight:900; font-size:32px; backdrop-filter:blur(6px); white-space:nowrap; }

    #overlay { position:fixed; inset:0; z-index:999999; display:grid; place-items:start center; background:radial-gradient(1200px 800px at 50% 30%,rgba(255,255,255,.07),rgba(0,0,0,.65)); color:#fff; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:20px 0; }
    #overlay.hidden { display:none; }
    .card { width:min(860px,94%); margin:0 auto; border-radius:18px; border:1px solid rgba(255,255,255,.14); background:rgba(20,10,18,.95); padding:20px; box-shadow:0 16px 40px rgba(0,0,0,.6); text-align:center; }
    .card h1 { margin:6px 0; font-size:20px; }
    .card p  { margin:6px 0; opacity:.92; font-size:13px; line-height:1.4; }
    .btn { display:block; width:100%; margin-top:12px; padding:13px 14px; border-radius:14px; border:none; cursor:pointer; font-weight:900; font-size:15px; background:linear-gradient(180deg,#ffcf4a,#ff9f2e); color:#2a1500; box-shadow:0 8px 20px rgba(0,0,0,.4); -webkit-tap-highlight-color:transparent; }
    .btn:active { transform:scale(.98); opacity:.9; }
    .btn.grey { background:linear-gradient(180deg,#eee,#ccc); color:#111; }
    .settingRow { margin-top:10px; text-align:left; background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.14); border-radius:14px; padding:14px; }
    .rowLabel { display:flex; justify-content:space-between; align-items:center; font-weight:800; font-size:13px; margin-bottom:8px; }
    input[type="range"] { width:100%; cursor:pointer; }
    input[type="file"]  { width:100%; max-width:100%; cursor:pointer; }
    input[type="number"] { width:58px; padding:4px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.25); background:rgba(0,0,0,.4); color:#fff; font-weight:800; font-size:13px; text-align:center; }
    .assetGrid { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; }
    .assetCol  { flex:1 1 155px; min-width:150px; }
    .assetPreviewRow { margin-top:6px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .assetNote { font-size:11px; opacity:.85; line-height:1.3; }
    .pointRow { display:flex; align-items:center; gap:6px; margin-top:7px; font-size:12px; font-weight:700; }
    .pointRow span { opacity:.8; }
    #drumStatus { margin-top:8px; font-size:12px; font-weight:700; color:#7dffb3; text-align:center; padding:8px 10px; background:rgba(0,0,0,.3); border-radius:10px; }
    .sectionTitle { font-weight:900; font-size:13px; margin-bottom:10px; padding-bottom:6px; border-bottom:1px solid rgba(255,255,255,.12); }
    .hint { margin-top:10px; font-size:12px; opacity:.75; text-align:center; }
    .gpRow { display:flex; gap:8px; flex-wrap:wrap; align-items:center; font-size:12px; margin-top:8px; }
    .gpRow label { display:flex; align-items:center; gap:4px; font-weight:700; }
  </style>
</head>
<body>
<div id="frame">
  <div id="bgLayer">
    <img id="bgImg"/>
  </div>
  <div id="bgTint"></div>

  <div class="hud">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Time: <span id="time">30</span>s</div>
  </div>

  <canvas id="c"></canvas>

  <div id="overlay">
    <div class="card">
      <h1 id="title">üßß Caring Tap Game</h1>
      <p id="desc">After START: you must <b>HIT 3 TIMES</b> to begin.<br/>During game: hit logos = points. Hit BOOM = penalty.</p>

      <!-- SPEED -->
      <div class="settingRow">
        <div class="rowLabel">Speed (Hardness) <span id="speedLabel">1.0x</span></div>
        <input id="speed" type="range" min="0.7" max="6.0" step="0.1" value="1.5" />
        <p style="margin:5px 0 0;font-size:12px;opacity:.8;">Higher = faster notes &amp; beats.</p>
      </div>

      <!-- DRUM CONTROLLER -->
      <div class="settingRow">
        <div class="sectionTitle">ü•Å Drum Controller</div>
        <div id="drumStatus">Waiting‚Ä¶ plug in drum and press a pad.</div>
        <p style="margin:8px 0 4px;font-size:12px;opacity:.85;">
          Supports any USB/Bluetooth gamepad (Taiko controller, etc).<br/>
          Tapping the drum on screen works too.
        </p>
        <div style="margin-top:10px;">
          <div style="font-weight:800;font-size:12px;margin-bottom:6px;">üîç Button Tester ‚Äî press your drum pads now:</div>
          <div id="btnTester" style="font-family:monospace;font-size:12px;background:rgba(0,0,0,.4);border-radius:8px;padding:8px;min-height:36px;color:#7dffb3;">Hit any pad to see button numbers‚Ä¶</div>
          <div style="margin-top:8px;font-weight:800;font-size:12px;margin-bottom:4px;">Map buttons to hit action (enter numbers from tester above):</div>
          <div class="gpRow">
            <label>Don L: <input type="number" id="btnDonL" value="0" min="0" max="63"></label>
            <label>Don R: <input type="number" id="btnDonR" value="1" min="0" max="63"></label>
            <label>Ka L:  <input type="number" id="btnKaL"  value="2" min="0" max="63"></label>
            <label>Ka R:  <input type="number" id="btnKaR"  value="3" min="0" max="63"></label>
          </div>
          <p style="margin:5px 0 0;font-size:11px;opacity:.7;">Set all 4 to the same number if your drum only has one zone.</p>
        </div>
      </div>

      <!-- AUDIO -->
      <div class="settingRow">
        <div class="sectionTitle">üîä Audio Settings</div>
        <div style="display:grid;gap:12px;">
          <div>
            <div class="rowLabel">Drum FX Volume <span id="drumVolLabel">80%</span></div>
            <input id="drumVol" type="range" min="0" max="1" step="0.01" value="0.80" />
          </div>
          <div>
            <div class="rowLabel">Background Music Volume <span id="musicVolLabel">35%</span></div>
            <input id="musicVol" type="range" min="0" max="1" step="0.01" value="0.35" />
          </div>
          <div>
            <div style="font-weight:800;font-size:12px;margin-bottom:5px;">Upload Background Music (loop)</div>
            <input id="musicFile" type="file" accept="audio/*" />
            <div id="musicStatus" style="margin-top:5px;font-size:11px;color:#7dffb3;min-height:16px;"></div>
            <button class="btn grey" id="resetMusic" style="margin-top:6px;">Reset Music (Default)</button>
          </div>
          <div>
            <div style="font-weight:800;font-size:12px;margin-bottom:5px;">Upload Drum Hit SFX</div>
            <input id="drumFile" type="file" accept="audio/*" />
            <div id="drumSfxStatus" style="margin-top:5px;font-size:11px;color:#7dffb3;min-height:16px;"></div>
            <button class="btn grey" id="resetDrum" style="margin-top:6px;">Reset Drum SFX (Default)</button>
          </div>
        </div>
      </div>

      <!-- ASSETS + POINTS -->
      <div class="settingRow">
        <div class="sectionTitle">üñºÔ∏è Images &amp; Points per Hit</div>
        <div class="assetGrid">

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">Logo 1 (main)</div>
            <input id="logoFile" type="file" accept="image/*" />
            <div class="assetPreviewRow">
              <canvas id="logoPrev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">Circle crop</div>
            </div>
            <div class="pointRow"><span>Hit:</span><input type="number" id="logo1pts" value="1" min="-99" max="99"><span>pts</span></div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">Logo 2</div>
            <input id="logo2File" type="file" accept="image/*" />
            <div class="assetPreviewRow">
              <canvas id="logo2Prev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">Optional</div>
            </div>
            <div class="pointRow"><span>Hit:</span><input type="number" id="logo2pts" value="2" min="-99" max="99"><span>pts</span></div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">Logo 3</div>
            <input id="logo3File" type="file" accept="image/*" />
            <div class="assetPreviewRow">
              <canvas id="logo3Prev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">Optional</div>
            </div>
            <div class="pointRow"><span>Hit:</span><input type="number" id="logo3pts" value="3" min="-99" max="99"><span>pts</span></div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">BOOM (penalty)</div>
            <input id="boomFile" type="file" accept="image/*" />
            <div class="assetPreviewRow">
              <canvas id="boomPrev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">Default firecracker</div>
            </div>
            <div class="pointRow"><span>Hit:</span><input type="number" id="boompts" value="-5" min="-99" max="99"><span>pts</span></div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">DRUM image (the hit circle)</div>
            <input id="hitFile" type="file" accept="image/*" />
            <div class="assetPreviewRow">
              <canvas id="hitPrev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">On drum</div>
            </div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">Game Background (during play)</div>
            <input id="bgFile" type="file" accept="image/*" />
            <div id="bgStatus" style="font-size:11px;color:#7dffb3;margin-top:4px;min-height:14px;"></div>
            <div class="assetPreviewRow">
              <canvas id="bgPrev" width="66" height="66" style="border-radius:10px;border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.25);"></canvas>
              <div class="assetNote">GIF ‚úÖ</div>
            </div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">READY Background (Hit 3 times to start)</div>
            <input id="readyBgFile" type="file" accept="image/*" />
            <div id="readyBgStatus" style="font-size:11px;color:#7dffb3;margin-top:4px;min-height:14px;"></div>
          </div>

          <div class="assetCol">
            <div style="font-weight:800;font-size:11px;margin-bottom:4px;">END Background (Score/Timeout page)</div>
            <input id="endBgFile" type="file" accept="image/*" />
            <div id="endBgStatus" style="font-size:11px;color:#7dffb3;margin-top:4px;min-height:14px;"></div>
          </div>

        </div>
        <button class="btn grey" id="resetAssets" style="margin-top:12px;">Reset All Assets (Default)</button>
        <p style="margin:7px 0 0;font-size:11px;opacity:.7;">All uploads saved in browser storage.</p>
      </div>

      <button class="btn" id="startBtn" style="font-size:17px;padding:15px;margin-top:16px;">‚ñ∂ START</button>
      <div class="hint">Keyboard: <b>F</b> or <b>J</b> to hit &nbsp;|&nbsp; ESC = exit fullscreen</div>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

// ---------- DEFAULTS (files must be beside drum.html) ----------
const DEFAULT_READY_BG_URL = "1.gif";
const DEFAULT_GAME_BG_URL  = "2.gif";
const DEFAULT_END_BG_URL   = "3.svg";

const DEFAULT_LOGO1_URL = "logo1.jpeg";
const DEFAULT_LOGO2_URL = "logo2.jpeg";
const DEFAULT_LOGO3_URL = "logo3.jpeg";
const DEFAULT_BOOM_URL  = "boom.jpeg";
const DEFAULT_HIT_ICON_URL = "logo3.jpeg"; // if you don't have drum.png yet, temporarily use "logo3.jpeg"

const DEFAULT_MUSIC_URL    = "bgmusic.mp3";
const DEFAULT_DRUM_SFX_URL = "soundeffect.mp3";

// ---------- PRELOAD DEFAULT BACKGROUNDS (reduce first-time delay) ----------
const _preloadBg = (() => {
  const a = new Image(); a.src = DEFAULT_READY_BG_URL;
  const b = new Image(); b.src = DEFAULT_GAME_BG_URL;
  const c = new Image(); c.src = DEFAULT_END_BG_URL;
  return { a,b,c };
})();


  // ---------- ELEMENTS ----------
  const frame    = document.getElementById("frame");
  const bgLayer  = document.getElementById("bgLayer");
  const bgImgEl  = document.getElementById("bgImg");
  

  // Start loading the first wallpaper immediately (no delay on first screen)
  setBg(DEFAULT_READY_BG_URL);
const bgTint   = document.getElementById("bgTint");
  const canvas   = document.getElementById("c");
  const ctx      = canvas.getContext("2d");
  const scoreEl  = document.getElementById("score");
  const timeEl   = document.getElementById("time");
  const overlay  = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const drumStatusEl = document.getElementById("drumStatus");

  function showMenu() { overlay.classList.remove("hidden"); canvas.classList.remove("active"); }
  function hideMenu() { overlay.classList.add("hidden");   canvas.classList.add("active"); }
  showMenu();

  async function goFullscreen() {
    try { if (!document.fullscreenElement && frame.requestFullscreen) await frame.requestFullscreen(); } catch(e){}
  }

  function resize() {
    const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
    canvas.width =Math.floor(window.innerWidth *dpr);
    canvas.height=Math.floor(window.innerHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize",resize);
  document.addEventListener("fullscreenchange",resize);
  resize();

  // Speed
const speedSlider = document.getElementById("speed");
const speedLabel  = document.getElementById("speedLabel");

// ‚úÖ Default speed comes from slider value
let speedMul = Number(speedSlider.value);
speedLabel.textContent = speedMul.toFixed(1) + "x";

speedSlider.addEventListener("input", () => {
  speedMul = Number(speedSlider.value);
  speedLabel.textContent = speedMul.toFixed(1) + "x";
});
// LS keys
  const LS={
    LOGO1:"cg_logo1",LOGO2:"cg_logo2",LOGO3:"cg_logo3",BOOM:"cg_boom",HIT:"cg_hit",
    MUSIC:"cg_music",DRUM_SFX:"cg_drum_sfx",PTS:"cg_points",
  };

  // IndexedDB keys for page backgrounds (unlimited size)
  const IDB_NAME = "caringGame", IDB_STORE = "assets";
  const IDB_GAME_BG_KEY  = "bg_game_blob";
  const IDB_READY_BG_KEY = "bg_ready_blob";
  const IDB_END_BG_KEY   = "bg_end_blob";

  function openIDB(){
    return new Promise((res,rej)=>{
      const req = indexedDB.open(IDB_NAME, 1);
      req.onupgradeneeded = e => e.target.result.createObjectStore(IDB_STORE);
      req.onsuccess = e => res(e.target.result);
      req.onerror   = e => rej(e.target.error);
    });
  }
  function idbSet(key, val){
    return openIDB().then(db => new Promise((res,rej)=>{
      const tx = db.transaction(IDB_STORE,"readwrite");
      tx.objectStore(IDB_STORE).put(val, key);
      tx.oncomplete = res; tx.onerror = rej;
    }));
  }
  function idbGet(key){
    return openIDB().then(db => new Promise((res,rej)=>{
      const req = db.transaction(IDB_STORE,"readonly").objectStore(IDB_STORE).get(key);
      req.onsuccess = e => res(e.target.result);
      req.onerror   = e => rej(e.target.error);
    }));
  }
  function idbDel(key){
    return openIDB().then(db => new Promise((res,rej)=>{
      const tx = db.transaction(IDB_STORE,"readwrite");
      tx.objectStore(IDB_STORE).delete(key);
      tx.oncomplete = res; tx.onerror = rej;
    }));
  }

  function readFile(f){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload=()=>res(fr.result);
      fr.onerror=rej;
      fr.readAsDataURL(f);
    });
  }

  // ---------- BACKGROUND MANAGER ----------
  const bgObjectUrls = { game:null, ready:null, end:null };

function setBg(src){
  if(src){
    bgImgEl.style.display = "block";
    bgImgEl.onerror = () => {
      // if image fails, fall back to gradient
      bgImgEl.style.display = "none";
      bgImgEl.src = "";
      bgLayer.style.backgroundImage = ""; // keep your CSS gradient
    };
    bgImgEl.src = src;
  } else {
    bgImgEl.style.display = "none";
    bgImgEl.src = "";
    bgLayer.style.backgroundImage = ""; // keep your CSS gradient
  }
}

  function revokeBgUrl(which){
    if(bgObjectUrls[which]){
      URL.revokeObjectURL(bgObjectUrls[which]);
      bgObjectUrls[which]=null;
    }
  }

  function applyBgBlob(which, blob){
    revokeBgUrl(which);
    bgObjectUrls[which] = URL.createObjectURL(blob);
    setBg(bgObjectUrls[which]);
  }

  function updateBgStatus(el, sizeBytes){
    if(sizeBytes > 0){
      el.textContent = "‚úÖ Saved (" + Math.round(sizeBytes/1024) + " KB)";
      el.style.color = "#7dffb3";
    } else {
      el.textContent = "‚¨ú Using default";
      el.style.color = "rgba(255,255,255,0.55)";
    }
  }

  const bgStatusEl = document.getElementById("bgStatus");
  const readyBgStatusEl = document.getElementById("readyBgStatus");
  const endBgStatusEl = document.getElementById("endBgStatus");

  async function loadStageBg(stage){
    try{
      if(stage==="ready"){
        const blob = await idbGet(IDB_READY_BG_KEY);
        if(blob){ applyBgBlob("ready", blob); updateBgStatus(readyBgStatusEl, blob.size); return; }
        updateBgStatus(readyBgStatusEl, 0);
        setBg(DEFAULT_READY_BG_URL);
        return;
      }
      if(stage==="game"){
        const blob = await idbGet(IDB_GAME_BG_KEY);
        if(blob){ applyBgBlob("game", blob); updateBgStatus(bgStatusEl, blob.size); return; }
        updateBgStatus(bgStatusEl, 0);
        setBg(DEFAULT_GAME_BG_URL);
        return;
      }
      if(stage==="end"){
        const blob = await idbGet(IDB_END_BG_KEY);
        if(blob){ applyBgBlob("end", blob); updateBgStatus(endBgStatusEl, blob.size); return; }
        updateBgStatus(endBgStatusEl, 0);
        setBg(DEFAULT_END_BG_URL);
        return;
      }
    }catch(e){
      // fallback
      if(stage==="ready") setBg(DEFAULT_READY_BG_URL);
      if(stage==="game")  setBg(DEFAULT_GAME_BG_URL);
      if(stage==="end")   setBg(DEFAULT_END_BG_URL);
    }
  }

  // Bind uploads
  document.getElementById("bgFile").addEventListener("change", async e=>{
    const f = e.target.files?.[0]; if(!f) return;
    setBg(URL.createObjectURL(f));
    bgStatusEl.textContent = "üíæ Saving‚Ä¶";
    bgStatusEl.style.color = "#ffd54a";
    try{
      await idbSet(IDB_GAME_BG_KEY, f);
      updateBgStatus(bgStatusEl, f.size);
    }catch(err){
      bgStatusEl.textContent = "‚ùå Could not save: " + err.message;
      bgStatusEl.style.color = "#ff6b6b";
    }
  });

  document.getElementById("readyBgFile").addEventListener("change", async e=>{
    const f = e.target.files?.[0]; if(!f) return;
    setBg(URL.createObjectURL(f));
    readyBgStatusEl.textContent = "üíæ Saving‚Ä¶";
    readyBgStatusEl.style.color = "#ffd54a";
    try{
      await idbSet(IDB_READY_BG_KEY, f);
      updateBgStatus(readyBgStatusEl, f.size);
    }catch(err){
      readyBgStatusEl.textContent = "‚ùå Could not save: " + err.message;
      readyBgStatusEl.style.color = "#ff6b6b";
    }
  });

  document.getElementById("endBgFile").addEventListener("change", async e=>{
    const f = e.target.files?.[0]; if(!f) return;
    setBg(URL.createObjectURL(f));
    endBgStatusEl.textContent = "üíæ Saving‚Ä¶";
    endBgStatusEl.style.color = "#ffd54a";
    try{
      await idbSet(IDB_END_BG_KEY, f);
      updateBgStatus(endBgStatusEl, f.size);
    }catch(err){
      endBgStatusEl.textContent = "‚ùå Could not save: " + err.message;
      endBgStatusEl.style.color = "#ff6b6b";
    }
  });

  // Restore default status labels on load (actual bg applied by stage)
  (async function restoreBgStatuses(){
    try{
      const g = await idbGet(IDB_GAME_BG_KEY); updateBgStatus(bgStatusEl, g?g.size:0);
      const r = await idbGet(IDB_READY_BG_KEY); updateBgStatus(readyBgStatusEl, r?r.size:0);
      const ed = await idbGet(IDB_END_BG_KEY); updateBgStatus(endBgStatusEl, ed?ed.size:0);
    }catch(e){}
  })();

  // ---------- POINTS ----------
  let pts={ logo1:2, logo2:4, logo3:6, boom:-2 };
  try{ const s=localStorage.getItem(LS.PTS); if(s) pts=JSON.parse(s); }catch(e){}
  const ptsEl={ logo1:document.getElementById("logo1pts"), logo2:document.getElementById("logo2pts"), logo3:document.getElementById("logo3pts"), boom:document.getElementById("boompts") };
  ptsEl.logo1.value=pts.logo1; ptsEl.logo2.value=pts.logo2; ptsEl.logo3.value=pts.logo3; ptsEl.boom.value=pts.boom;
  function savePts(){ pts.logo1=parseInt(ptsEl.logo1.value)||0; pts.logo2=parseInt(ptsEl.logo2.value)||0; pts.logo3=parseInt(ptsEl.logo3.value)||0; pts.boom=parseInt(ptsEl.boom.value)||0; localStorage.setItem(LS.PTS,JSON.stringify(pts)); }
  Object.values(ptsEl).forEach(el=>el.addEventListener("change",savePts));

  // ---------- IMAGES ----------
  function makeImg(){ const i=new Image(); if(location.protocol==="http:"||location.protocol==="https:") i.crossOrigin="anonymous"; return i; }
  const imgs={ logo1:makeImg(),logo2:makeImg(),logo3:makeImg(),boom:makeImg(),hit:makeImg() };
  const rdy={ logo1:false,logo2:false,logo3:false,boom:false,hit:false };

  function loadImg(key,src){
    rdy[key]=false;
    imgs[key].onload=()=>{ rdy[key]=true; drawPreviews(); };
    imgs[key].onerror=()=>{ rdy[key]=false; drawPreviews(); };
    if(src) imgs[key].src=src;
  }

  loadImg("logo1",localStorage.getItem(LS.LOGO1)||DEFAULT_LOGO1_URL);
  loadImg("logo2",localStorage.getItem(LS.LOGO2)||DEFAULT_LOGO2_URL);
  loadImg("logo3",localStorage.getItem(LS.LOGO3)||DEFAULT_LOGO3_URL);
  loadImg("boom", localStorage.getItem(LS.BOOM)||DEFAULT_BOOM_URL);
  loadImg("hit",  localStorage.getItem(LS.HIT)||DEFAULT_HIT_ICON_URL);

  function bindFile(id,lsKey,imgKey){
    document.getElementById(id).addEventListener("change",async e=>{
      const f=e.target.files?.[0];
      if(!f) return;
      const url=await readFile(f);
      localStorage.setItem(lsKey,url);
      if(imgKey) loadImg(imgKey,url);
    });
  }
  bindFile("logoFile", LS.LOGO1,"logo1");
  bindFile("logo2File",LS.LOGO2,"logo2");
  bindFile("logo3File",LS.LOGO3,"logo3");
  bindFile("boomFile", LS.BOOM, "boom");
  bindFile("hitFile",  LS.HIT,  "hit");

  // Reset all assets
  document.getElementById("resetAssets").addEventListener("click",async ()=>{
    [LS.LOGO1,LS.LOGO2,LS.LOGO3,LS.BOOM,LS.HIT].forEach(k=>localStorage.removeItem(k));
    ["logoFile","logo2File","logo3File","boomFile","hitFile","bgFile","readyBgFile","endBgFile"].forEach(id=>document.getElementById(id).value="");

    loadImg("logo1",DEFAULT_LOGO1_URL);
    loadImg("logo2",DEFAULT_LOGO2_URL);
    loadImg("logo3",DEFAULT_LOGO3_URL);
    loadImg("boom", DEFAULT_BOOM_URL);
    loadImg("hit",  DEFAULT_HIT_ICON_URL);

    await idbDel(IDB_GAME_BG_KEY).catch(()=>{});
    await idbDel(IDB_READY_BG_KEY).catch(()=>{});
    await idbDel(IDB_END_BG_KEY).catch(()=>{});

    revokeBgUrl("game"); revokeBgUrl("ready"); revokeBgUrl("end");

    // Just return to menu bg (doesn't matter which), defaults show by stage
    setBg(null);
    updateBgStatus(bgStatusEl,0);
    updateBgStatus(readyBgStatusEl,0);
    updateBgStatus(endBgStatusEl,0);

    // Reset audio to default
    localStorage.setItem(LS.MUSIC, DEFAULT_MUSIC_URL);
    localStorage.setItem(LS.DRUM_SFX, DEFAULT_DRUM_SFX_URL);
    bgMusicEl.src = DEFAULT_MUSIC_URL;
    drumBuffer=null; await loadDrumBuf(DEFAULT_DRUM_SFX_URL);
    showAudioStatus();

    drawPreviews();
  });

  // Previews
  const pCtx={ logo1:document.getElementById("logoPrev").getContext("2d"), logo2:document.getElementById("logo2Prev").getContext("2d"), logo3:document.getElementById("logo3Prev").getContext("2d"), boom:document.getElementById("boomPrev").getContext("2d"), hit:document.getElementById("hitPrev").getContext("2d"), bg:document.getElementById("bgPrev").getContext("2d") };
  function drawCirclePrev(pc,img,isRdy,label){
    const w=pc.canvas.width,h=pc.canvas.height;
    pc.clearRect(0,0,w,h);
    pc.fillStyle="rgba(0,0,0,.25)";
    pc.fillRect(0,0,w,h);
    const r=Math.min(w,h)*0.41,cx=w/2,cy=h/2;
    pc.save();
    pc.beginPath();
    pc.arc(cx,cy,r,0,Math.PI*2);
    pc.clip();
    if(isRdy){
      const s=Math.max(r*2/img.width,r*2/img.height);
      pc.drawImage(img,cx-img.width*s/2,cy-img.height*s/2,img.width*s,img.height*s);
    }else{
      pc.fillStyle="rgba(255,255,255,.08)";
      pc.fillRect(cx-r,cy-r,r*2,r*2);
      pc.fillStyle="#fff";
      pc.font="bold 9px system-ui";
      pc.textAlign="center";
      pc.textBaseline="middle";
      pc.fillText(label,cx,cy);
    }
    pc.restore();
    pc.strokeStyle="rgba(255,255,255,.7)";
    pc.lineWidth=2;
    pc.beginPath();
    pc.arc(cx,cy,r,0,Math.PI*2);
    pc.stroke();
  }
  function drawPreviews(){
    ["logo1","logo2","logo3","boom","hit"].forEach(k=>drawCirclePrev(pCtx[k],imgs[k],rdy[k],k.toUpperCase()));
    const pc=pCtx.bg,w=pc.canvas.width,h=pc.canvas.height;
    pc.clearRect(0,0,w,h);
    pc.fillStyle="rgba(255,255,255,.08)";
    pc.fillRect(0,0,w,h);
    pc.fillStyle="#fff";
    pc.font="bold 9px system-ui";
    pc.textAlign="center";
    pc.textBaseline="middle";
    pc.fillText("BG",w/2,h/2);
    pc.strokeStyle="rgba(255,255,255,.5)";
    pc.lineWidth=2;
    pc.strokeRect(3,3,w-6,h-6);
  }
  setTimeout(drawPreviews,300);

  // ---------- AUDIO ----------
  let audioCtx=null,drumGain=null,musicGain=null,drumBuffer=null;
  const bgMusicEl=new Audio();
  bgMusicEl.loop=true;

// Always reset to default music when opening file
localStorage.setItem(LS.MUSIC, DEFAULT_MUSIC_URL);
  if(!localStorage.getItem(LS.DRUM_SFX)) localStorage.setItem(LS.DRUM_SFX, DEFAULT_DRUM_SFX_URL);

  bgMusicEl.src = localStorage.getItem(LS.MUSIC);

  let drumVol=0.80,musicVol=0.35;
  const drumVolLabel=document.getElementById("drumVolLabel"),musicVolLabel=document.getElementById("musicVolLabel");
  function pct(v){return Math.round(v*100)+"%";}
  drumVolLabel.textContent=pct(drumVol); musicVolLabel.textContent=pct(musicVol);
  document.getElementById("drumVol").addEventListener("input",e=>{ drumVol=Number(e.target.value); drumVolLabel.textContent=pct(drumVol); if(drumGain)drumGain.gain.value=drumVol; });
  document.getElementById("musicVol").addEventListener("input",e=>{ musicVol=Number(e.target.value); musicVolLabel.textContent=pct(musicVol); bgMusicEl.volume = musicVol; });

 function initAudio(){
  if(audioCtx) return;

  // WebAudio only for DRUM SFX
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  drumGain = audioCtx.createGain();
  drumGain.gain.value = drumVol;
  drumGain.connect(audioCtx.destination);

  // Background music: use HTMLAudio directly (more stable on file:///)
  bgMusicEl.volume = musicVol;
  bgMusicEl.muted = false;
}
  async function unlockAudio(){ initAudio(); if(audioCtx.state==="suspended") await audioCtx.resume(); audioUnlockedOnce = true; }

  let audioUnlockedOnce = false;

  // Small reminder beep (only works after the browser allows audio)
  function reminderBeep(){
    try{
      if(!audioCtx || audioCtx.state!=="running") return;
      const now = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = 880;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + 0.09);
    }catch(e){}
  }


  const musicStatusEl   = document.getElementById("musicStatus");
  const drumSfxStatusEl = document.getElementById("drumSfxStatus");

  function showAudioStatus(){
    const mVal = localStorage.getItem(LS.MUSIC);
    const dVal = localStorage.getItem(LS.DRUM_SFX);
    musicStatusEl.textContent   = mVal ? "‚úÖ Saved" : "‚¨ú None";
    musicStatusEl.style.color   = mVal ? "#7dffb3" : "rgba(255,255,255,0.45)";
    drumSfxStatusEl.textContent = dVal ? "‚úÖ Saved" : "‚¨ú None";
    drumSfxStatusEl.style.color = dVal ? "#7dffb3" : "rgba(255,255,255,0.45)";
  }
  showAudioStatus();

  document.getElementById("musicFile").addEventListener("change", async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const url = await readFile(f);
    try{
      localStorage.setItem(LS.MUSIC, url);
      bgMusicEl.src = url;
      if(running) bgMusicEl.play().catch(()=>{});
      showAudioStatus();
    } catch(err){
      musicStatusEl.textContent = "‚ùå Could not save. Will play this session only.";
      musicStatusEl.style.color = "#ff6b6b";
      bgMusicEl.src = url;
    }
  });

  document.getElementById("resetMusic").addEventListener("click",()=>{
    localStorage.setItem(LS.MUSIC, DEFAULT_MUSIC_URL);
    document.getElementById("musicFile").value="";
    bgMusicEl.pause();
    bgMusicEl.src = DEFAULT_MUSIC_URL;
    showAudioStatus();
  });

  async function loadDrumBuf(url){
    await unlockAudio();
    return new Promise(resolve=>{
      try{
        fetch(url).then(r=>r.arrayBuffer()).then(ab=>audioCtx.decodeAudioData(ab))
          .then(buf=>{drumBuffer=buf;resolve();})
          .catch(()=>{drumBuffer=null;resolve();});
      }catch(e){drumBuffer=null;resolve();}
    });
  }
  loadDrumBuf(localStorage.getItem(LS.DRUM_SFX));

  document.getElementById("drumFile").addEventListener("change", async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const url = await readFile(f);
    try{
      localStorage.setItem(LS.DRUM_SFX, url);
      await loadDrumBuf(url);
      showAudioStatus();
    } catch(err){
      drumSfxStatusEl.textContent = "‚ùå Could not save. Will play this session only.";
      drumSfxStatusEl.style.color = "#ff6b6b";
      await loadDrumBuf(url);
    }
  });

  document.getElementById("resetDrum").addEventListener("click",async ()=>{
    localStorage.setItem(LS.DRUM_SFX, DEFAULT_DRUM_SFX_URL);
    document.getElementById("drumFile").value="";
    drumBuffer=null;
    await loadDrumBuf(DEFAULT_DRUM_SFX_URL);
    showAudioStatus();
  });

  function playSynth(){
    if(!audioCtx||audioCtx.state!=="running")return;
    const t=audioCtx.currentTime,o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.type="sine";
    o.frequency.setValueAtTime(150,t);
    o.frequency.exponentialRampToValueAtTime(90,t+0.12);
    g.gain.setValueAtTime(0.3,t);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.25);
    o.connect(g); g.connect(drumGain);
    o.start(t); o.stop(t+0.26);
  }
  async function playDrum(){
    await unlockAudio();
    if(!drumBuffer) await loadDrumBuf(localStorage.getItem(LS.DRUM_SFX));
    if(drumBuffer&&audioCtx.state==="running"){
      const s=audioCtx.createBufferSource();
      s.buffer=drumBuffer;
      s.connect(drumGain);
      s.start();
    }else playSynth();
  }

  // ---------- GAMEPAD / DRUM CONTROLLER ----------
  const gpPrev = {};
  const btnTesterEl = document.getElementById("btnTester");

  function updateDrumStatus(){
    const gpList = navigator.getGamepads ? navigator.getGamepads() : [];
    const connected = [...gpList].filter(Boolean);
    if(connected.length === 0){
      drumStatusEl.textContent = "‚ö†Ô∏è No gamepad detected ‚Äî plug in drum & press a pad.";
      drumStatusEl.style.color = "#ffd54a";
    } else {
      drumStatusEl.textContent = "‚úÖ " + connected.map(g=>`[${g.index}] ${g.id.substring(0,40)} (${g.buttons.length} btns)`).join(" | ");
      drumStatusEl.style.color = "#7dffb3";
    }
  }
  window.addEventListener("gamepadconnected", updateDrumStatus);
  window.addEventListener("gamepaddisconnected", updateDrumStatus);
  updateDrumStatus();

  // ---------- GAME LOGIC ----------
  const GAME_SECS=30,BASE_VX=420,HIT_ICON_SZ=330,HIT_RADIUS=185,HIT_WINDOW=180,LANE_GAP=140,MIN_NOTE_GAP=130,SPAWN_MARGIN=80;
  const items=[],pops=[];
  let running=false,score=0,timeLeft=0,last=0,nextBeatIn=0,bonusMode=false,drumFlash=0;
  let hitX=0,hitY=0,laneY1=0,laneY2=0;

  // NEW STATES
  let isReadyScreen = false;
  let readyHitCount = 0;
  const readyNeeded = 3;

  let isEndScreen = false;
  let drumRestartCount = 0;
  const drumRestartNeeded = 3;
  let endScreenLoop = null;
  let endScreenStartTime = 0;
let endInputLocked = false; // lock input during TIME OUT countdown

  const END_COOLDOWN = 0.0; // no cooldown now (you asked immediate hit-3)

  const rand=(a,b)=>a+Math.random()*(b-a);

  function activeLogoTypes(){
    const t=["logo1"];
    if(rdy.logo2)t.push("logo2");
    if(rdy.logo3)t.push("logo3");
    return t;
  }
  function beatInterval(){
    if(bonusMode)return 0.22;
    return Math.max(0.40,0.70/Math.sqrt(speedMul));
  }

  function trySpawnInLane(laneY,type){
    const size=rand(72,96),half=size*0.5,sw=window.innerWidth;
    let rm=-Infinity;
    for(const it of items){
      if(!it.alive)continue;
      if(Math.abs(it.y-laneY)<5&&it.x>rm)rm=it.x;
    }
    const idealX=sw+SPAWN_MARGIN+half;
    const minX=rm===-Infinity?idealX:rm+half+size+MIN_NOTE_GAP;
    items.push({type,x:Math.max(idealX,minX),y:laneY,size,alive:true});
  }

  function spawnGroup(){
    const lt=activeLogoTypes();
    const isBoom=Math.random()>(bonusMode?0.96:0.78);
    const type=isBoom?"boom":lt[Math.floor(Math.random()*lt.length)];
    const isDbl=Math.random()<(bonusMode?0.55:0.26);
    if(isDbl){trySpawnInLane(laneY1,type);trySpawnInLane(laneY2,type);}
    else trySpawnInLane(Math.random()<0.5?laneY1:laneY2,type);
  }

  function canHit(it){ return Math.abs(it.x-hitX)<=HIT_WINDOW; }

  function resolveHit(it){
    it.alive=false;
    const delta=pts[it.type]||0;
    score+=delta;
    const sign=delta>=0?"+":"";
    pops.push({x:it.x,y:it.y,txt:`${sign}${delta}`,t:0.7,col:delta>=0?"#7dffb3":"#ff6b6b"});
    scoreEl.textContent=score;
  }

  function hitTestAuto(){
    let best=null,bestD=Infinity;
    for(const it of items){
      if(!it.alive) continue;
      const d = Math.abs(it.x - hitX);
      if(d > HIT_WINDOW) continue;
      if(d < bestD){ bestD=d; best=it; }
    }
    if(best) resolveHit(best);
    else pops.push({x:hitX+60,y:hitY-60,txt:"MISS",t:0.45,col:"#ffd54a"});
  }

  function hitTestXY(px,py){
    const dx0=px-hitX,dy0=py-hitY;
    if(dx0*dx0+dy0*dy0>HIT_RADIUS*HIT_RADIUS){hitTestAuto();return;}
    let best=null,bestS=Infinity;
    for(const it of items){
      if(!it.alive||!canHit(it))continue;
      const r=it.size*0.6,dx=px-it.x,dy=py-it.y;
      if(dx*dx+dy*dy<=r*r){
        const s=Math.abs(it.x-hitX)*2.4+Math.abs(it.y-py)*0.8;
        if(s<bestS){bestS=s;best=it;}
      }
    }
    if(best)resolveHit(best);
    else pops.push({x:hitX+220,y:hitY,txt:"MISS",t:0.45,col:"#ffd54a"});
  }

  // DRAW HELPERS
  function drawCircleNote(img,size,isRdy,label){
    const r=size*0.5;
    ctx.globalAlpha=0.20;
    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.ellipse(0,r*1.05,r*0.85,r*0.28,0,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    ctx.save();
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.clip();

    if(isRdy){
      const sc=Math.max(size/img.width,size/img.height);
      ctx.drawImage(img,-img.width*sc/2,-img.height*sc/2,img.width*sc,img.height*sc);
    }else{
      ctx.fillStyle="rgba(255,255,255,.10)";
      ctx.fillRect(-r,-r,r*2,r*2);
      ctx.fillStyle="#fff";
      ctx.font=`900 ${Math.floor(size*0.22)}px system-ui`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(label,0,0);
    }
    ctx.restore();

    ctx.strokeStyle="rgba(255,255,255,.92)";
    ctx.lineWidth=5;
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.stroke();

    ctx.strokeStyle="rgba(255,213,74,.85)";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(0,0,r-9,0,Math.PI*2);
    ctx.stroke();
  }

  function drawHitDrum(){
    if(drumFlash>0){
      ctx.globalAlpha=(drumFlash/0.18)*0.50;
      ctx.fillStyle="#fff";
      ctx.beginPath();
      ctx.arc(hitX,hitY,HIT_RADIUS+70,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha=1;
    }
    ctx.globalAlpha=0.14;
    ctx.fillStyle="#ffd54a";
    ctx.beginPath();
    ctx.arc(hitX,hitY,HIT_RADIUS+46,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    ctx.strokeStyle="rgba(255,213,74,.95)";
    ctx.lineWidth=10;
    ctx.beginPath();
    ctx.arc(hitX,hitY,HIT_RADIUS,0,Math.PI*2);
    ctx.stroke();

    ctx.save();
    ctx.translate(hitX,hitY);
    drawCircleNote(imgs.hit,HIT_ICON_SZ,rdy.hit,"DRUM");
    ctx.restore();
  }

  function drawLanes(w){
    ctx.globalAlpha=0.18;
    ctx.strokeStyle="#ffd54a";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.moveTo(0,laneY1);ctx.lineTo(w,laneY1);
    ctx.moveTo(0,laneY2);ctx.lineTo(w,laneY2);
    ctx.stroke();
    ctx.globalAlpha=1;
  }

  function drawNote(it){
    ctx.save();
    ctx.translate(it.x,it.y);
    if(canHit(it)){
      ctx.strokeStyle="rgba(125,255,179,.95)";
      ctx.lineWidth=6;
      ctx.beginPath();
      ctx.arc(0,0,it.size*0.56+9,0,Math.PI*2);
      ctx.stroke();
    }
    if(it.type==="logo1") drawCircleNote(imgs.logo1,it.size,rdy.logo1,"L1");
    else if(it.type==="logo2") drawCircleNote(imgs.logo2,it.size,rdy.logo2,"L2");
    else if(it.type==="logo3") drawCircleNote(imgs.logo3,it.size,rdy.logo3,"L3");
    else drawCircleNote(imgs.boom,it.size,rdy.boom,"BOOM");
    ctx.restore();
  }

// --- Drum position tweak (saved) ---
const LS_POS = { X:"cg_hitXmul", Y:"cg_hitYmul" };
  // Reset saved drum position each time you open the file (so defaults apply)
  try{ localStorage.removeItem(LS_POS.X); localStorage.removeItem(LS_POS.Y); }catch(e){};
// One-time cleanup: prevent old saved positions forcing the drum into a wrong place
try{ if(!localStorage.getItem("cg_pos_v2")){ localStorage.removeItem(LS_POS.X); localStorage.removeItem(LS_POS.Y); localStorage.setItem("cg_pos_v2","1"); } }catch(e){}
let hitXMul = parseFloat(localStorage.getItem(LS_POS.X) || "0.00"); // default near lion mouth (right)
let hitYMul = parseFloat(localStorage.getItem(LS_POS.Y) || "0.50"); // slightly up

function updatePositions(){
  const w = window.innerWidth, h = window.innerHeight;

  hitX = Math.max(200, w * hitXMul);  // LEFT by default
  hitY = h * hitYMul;

  laneY1 = hitY - LANE_GAP * 0.5;
  laneY2 = hitY + LANE_GAP * 0.5;
}

  // ---------- MAIN GAME LOOP ----------
  function loop(now){
    if(!running) return;
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;

    const w=window.innerWidth,h=window.innerHeight;
    updatePositions();

    timeLeft-=dt;
    timeEl.textContent=Math.max(0,Math.ceil(timeLeft));

    if(!bonusMode && timeLeft<=5){
      bonusMode=true;
      pops.push({x:hitX,y:hitY-220,txt:"BONUS RUSH!",t:1.0,col:"#ffd54a"});
      bgTint.style.background="rgba(255,213,74,0.07)";
    }

    if(timeLeft<=0){ endGame(); return; }

    nextBeatIn-=dt;
    if(nextBeatIn<=0){ spawnGroup(); nextBeatIn=beatInterval(); }

    for(const it of items){
      if(!it.alive)continue;
      it.x-=BASE_VX*speedMul*dt;
      if(it.x<-260)it.alive=false;
    }
    for(const p of pops){ p.t-=dt; p.y-=30*dt; }
    if(drumFlash>0) drumFlash-=dt;

    ctx.clearRect(0,0,w,h);
    drawLanes(w);
    drawHitDrum();

    items.filter(i=>i.alive).sort((a,b)=>b.x-a.x).forEach(drawNote);

    for(const p of pops){
      if(p.t<=0)continue;
      ctx.globalAlpha=Math.min(1,p.t/0.2);
      ctx.fillStyle=p.col;
      ctx.font="900 26px system-ui";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(p.txt,p.x,p.y);
      ctx.globalAlpha=1;
    }

    requestAnimationFrame(loop);
  }

  function resetGame(){
    items.length=0; pops.length=0;
    score=0; timeLeft=GAME_SECS;
    bonusMode=false; nextBeatIn=0; drumFlash=0;
    scoreEl.textContent=0;
    timeEl.textContent=GAME_SECS;
    savePts();
  }

  async function startGame(){
    // Instant default background (prevents any flash/delay)
    setBg(DEFAULT_GAME_BG_URL);
    await loadStageBg("game");
    resetGame();
    running=true;
    isReadyScreen=false;
    isEndScreen=false;
    last=performance.now();
    bgTint.style.background="rgba(10,0,8,0.35)";
    if(bgMusicEl.src){
      bgMusicEl.currentTime=0;
      bgMusicEl.play().catch(()=>{});
    }
    requestAnimationFrame(loop);
  }

  // ---------- READY SCREEN (HIT 3 TIMES) ----------
  let readyLoop = null;

  async function showReadyScreen(){
    isReadyScreen=true;
    readyHitCount=0;
    running=false;
    isEndScreen=false;

    setBg(DEFAULT_READY_BG_URL);
    bgMusicEl.pause();

    overlay.classList.add("hidden");
    canvas.classList.add("active");

    let readyBeepNext = 0;
    function rloop(){
      if(!isReadyScreen) return;
      drawReadyScreen();
      // beep every ~1.2s (only after audio unlocked)
      const t = performance.now()/1000;
      //if(audioUnlockedOnce && t >= readyBeepNext){ reminderBeep(); readyBeepNext = t + 1.2; }
      readyLoop = requestAnimationFrame(rloop);
    }
    rloop();
  }

  function drawReadyScreen(){
    const w = window.innerWidth, h = window.innerHeight;
    updatePositions();
    ctx.clearRect(0,0,w,h);

    // Slight dark tint for readability
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(0,0,w,h);

    // Rotate 90¬∞ clockwise for sideways TV
    ctx.save();
    ctx.translate(w, 0);
    ctx.rotate(Math.PI / 2);
    const rw = h, rh = w;

    ctx.textAlign="center";
    ctx.textBaseline="middle";

    ctx.fillStyle="#ffd54a";
    ctx.font="900 " + Math.floor(rw*0.12) + "px system-ui";
    ctx.fillText("GET READY!", rw/2, rh*0.25);

    const t = performance.now()/1000;
    const bob = Math.sin(t*2.4) * (rh*0.010);
    const pulse = 0.75 + 0.25*(0.5+0.5*Math.sin(t*3.2));

    ctx.save();
    ctx.globalAlpha = 0.75 + 0.25*pulse;
    ctx.fillStyle="rgba(255,255,255,1)";
    ctx.font="800 " + Math.floor(rw*0.055) + "px system-ui";
    ctx.fillText("HIT 3 TIMES TO START", rw/2, rh*0.48 + bob);
    ctx.restore();

// Dots progress
const need = readyNeeded;
const dotR = Math.floor(rw * 0.030);
const gap  = dotR * 3.2;
const totalDotW = (need - 1) * gap;

// ‚úÖ These are tuned for the LEFT POLE gold circles (in rotated coords)
const DOT_CENTER_X = rw * 0.58;   // controls UP/DOWN on real screen
const DOT_CENTER_Y = rh * 0.94;   // controls LEFT/RIGHT on real screen (bigger = more left)

for (let i = 0; i < need; i++) {
  // ‚úÖ IMPORTANT: vary X (so it becomes vertical on real screen)
  const dx = DOT_CENTER_X - totalDotW / 2 + i * gap;
  const dy = DOT_CENTER_Y;

  ctx.beginPath();
  ctx.arc(dx, dy, dotR, 0, Math.PI * 2);
  ctx.fillStyle = i < readyHitCount ? "#ffd54a" : "rgba(255,255,255,0.20)";
  ctx.fill();
  ctx.strokeStyle = i < readyHitCount ? "#ffd54a" : "rgba(255,255,255,0.45)";
  ctx.lineWidth = 3;
  ctx.stroke();
}

    ctx.fillStyle="rgba(255,255,255,0.55)";
    ctx.font="600 " + Math.floor(rw*0.030) + "px system-ui";
    // removed keyboard hint

    ctx.restore();
  }

  async function readyScreenHit(){
    if(!isReadyScreen) return;
    readyHitCount++;
    playDrum().catch(()=>{});
    if(readyHitCount >= readyNeeded){
      isReadyScreen=false;
      if(readyLoop) cancelAnimationFrame(readyLoop);
      await startGame();
    }
  }

  // ---------- END SCREEN (SCORE + HIT 3 TO PLAY AGAIN) ----------
  function endGame(){
    running=false;
    // Instant default background (prevents any flash/delay)
    setBg(DEFAULT_END_BG_URL);
    isEndScreen=true;
    isReadyScreen=false;
    drumRestartCount=0;
    endScreenStartTime=performance.now();
    bgMusicEl.pause();

    loadStageBg("end");

    overlay.classList.add("hidden");
    canvas.classList.add("active");

    function endLoop(){
      if(!isEndScreen) return;
      drawEndScreen();
      endScreenLoop = requestAnimationFrame(endLoop);
    }
    endLoop();
  }

  function drawEndScreen(){
    const w=window.innerWidth,h=window.innerHeight;
    const elapsed=(performance.now()-endScreenStartTime)/1000;
    const fadeIn=Math.min(1,elapsed/0.4);
    const TIMEOUT_COUNTDOWN_SECS = 2.0;
    endInputLocked = (elapsed < TIMEOUT_COUNTDOWN_SECS);

    ctx.clearRect(0,0,w,h);

    // Tint overlay
    ctx.fillStyle = "rgba(0,0,0,"+(0.35*fadeIn)+")";
    ctx.fillRect(0,0,w,h);

    ctx.save();
    ctx.translate(w,0);
    ctx.rotate(Math.PI/2);
    const rw=h, rh=w;

    ctx.globalAlpha=fadeIn;
    ctx.textAlign="center";
    ctx.textBaseline="middle";

    const t = performance.now()/1000;

    // Phase 1: full black "TIME OUT" countdown splash
    if(elapsed < TIMEOUT_COUNTDOWN_SECS){
      ctx.restore();
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle="rgba(0,0,0,1)";
      ctx.fillRect(0,0,w,h);

      const remain = Math.max(0, TIMEOUT_COUNTDOWN_SECS - elapsed);
      const n = Math.max(0, Math.ceil(remain)); // 3..2..1..0
      const phase = 1 - (remain / TIMEOUT_COUNTDOWN_SECS); // 0->1
      const pulse = 0.85 + 0.15*Math.sin((performance.now()/1000)*4.0);

      ctx.save();
      ctx.translate(w,0);
      ctx.rotate(Math.PI/2);
      const rw=h, rh=w;
      ctx.textAlign="center";
      ctx.textBaseline="middle";

      // Fade in quickly
      const a = Math.min(1, elapsed/0.25);
      ctx.globalAlpha = a;

      // TIME OUT text
      ctx.fillStyle = "#ffffff";
      ctx.font = "900 " + Math.floor(rw*0.14) + "px system-ui";
      ctx.fillText("TIME OUT", rw/2, rh*0.42);

      // Countdown number with bounce
      if(n > 0){
        const scale = (1.15 - 0.25*phase) * pulse;
        ctx.save();
        ctx.translate(rw/2, rh*0.58);
        ctx.scale(scale, scale);
        ctx.font = "950 " + Math.floor(rw*0.18) + "px system-ui";
        ctx.fillText(String(n), 0, 0);
        ctx.restore();
      }


      // Circular progress bar (prevents "skip" feeling)
      const prog = Math.min(1, elapsed / TIMEOUT_COUNTDOWN_SECS); // 0..1
      const cx = rw/2, cy = rh*0.58;
      const radius = Math.min(rw, rh) * 0.11;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineWidth = Math.max(6, radius*0.12);
      // track
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI*2);
      ctx.stroke();
      // progress
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      // start at top (-90deg)
      ctx.arc(cx, cy, radius, -Math.PI/2, -Math.PI/2 + prog*Math.PI*2);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
      return;
    }

    // Phase 2: show end background + score
    const pulse = 0.75 + 0.25*(0.5+0.5*Math.sin(t*3.0));
    const bob = Math.sin(t*2.2) * (rh*0.012);

    ctx.fillStyle="#ffffff";
    ctx.font="950 " + Math.floor(rw*0.14) + "px system-ui";
    ctx.globalAlpha = 0.85 + 0.15*pulse;
    ctx.fillText(String(score), rw/2, rh*0.36 + bob);
    ctx.globalAlpha = 1;

    const hitsLeft = drumRestartNeeded - drumRestartCount;
    ctx.fillStyle="rgba(255,255,255,0.95)";
    ctx.font="800 " + Math.floor(rw*0.045) + "px system-ui";
    ctx.fillText("Hit " + hitsLeft + " more time" + (hitsLeft!==1?"s":"") + " to play again", rw/2, rh*0.60);

    // dots
    const dotR=Math.floor(rw*0.030);
    const gap=dotR*3.2;
    const totalDotW=(drumRestartNeeded-1)*gap;
    for(let i=0;i<drumRestartNeeded;i++){
      const dx=rw/2-totalDotW/2+i*gap;
      const dy=rh*0.74;
      ctx.beginPath();
      ctx.arc(dx,dy,dotR,0,Math.PI*2);
      ctx.fillStyle=i<drumRestartCount ? "#ffd54a" : "rgba(255,255,255,0.2)";
      ctx.fill();
      ctx.strokeStyle=i<drumRestartCount ? "#ffd54a" : "rgba(255,255,255,0.45)";
      ctx.lineWidth=3;
      ctx.stroke();
    }

    ctx.globalAlpha=1;
    ctx.restore();
  }

  async function endScreenHit(){
    if(!isEndScreen) return;
    drumRestartCount++;
    playDrum().catch(()=>{});
    if(drumRestartCount >= drumRestartNeeded){
      isEndScreen=false;
      if(endScreenLoop) cancelAnimationFrame(endScreenLoop);
      showReadyScreen(); // go back to READY page (hit 3 times again)
    }
  }

  // ---------- INPUT ROUTER ----------
  function triggerHit(){
    // Block any skipping during TIME OUT countdown
    if(isEndScreen && endInputLocked) return;

    drumFlash=0.18;

    if(isReadyScreen){
      readyScreenHit();
      return;
    }
    if(isEndScreen){
      endScreenHit();
      return;
    }
    if(!running) return;

    hitTestAuto();
    playDrum().catch(()=>{});
  }

  // Gamepad polling ‚Äî ANY button or axis on ANY connected gamepad triggers
  function pollGamepads(){
    const gpList = navigator.getGamepads ? navigator.getGamepads() : [];
    for(const gp of gpList){
      if(!gp) continue;
      if(!gpPrev[gp.index]) gpPrev[gp.index] = {};

      for(let bi=0; bi<gp.buttons.length; bi++){
        const isDown = gp.buttons[bi].pressed || gp.buttons[bi].value > 0.3;
        const wasDown = !!gpPrev[gp.index][bi];
        if(isDown && !wasDown){
          if(isReadyScreen || isEndScreen || running){
            triggerHit();
          } else {
            try{
              btnTesterEl.textContent = "ü•Å Button " + bi + " ‚Äî gamepad: " + gp.id.substring(0,40);
              btnTesterEl.style.color="#ffcf4a";
            }catch(e){}
          }
        }
        gpPrev[gp.index][bi]=isDown;
      }

      for(let ai=0; ai<gp.axes.length; ai++){
        const val=gp.axes[ai];
        const key="a"+ai;
        const isActive=Math.abs(val)>0.7;
        const wasActive=!!gpPrev[gp.index][key];
        if(isActive && !wasActive){
          if(isReadyScreen || isEndScreen || running){
            triggerHit();
          } else {
            try{
              btnTesterEl.textContent = "ü•Å Axis " + ai + " = " + val.toFixed(2) + " ‚Äî gamepad: " + gp.id.substring(0,40);
              btnTesterEl.style.color="#ff9f2e";
            }catch(e){}
          }
        }
        gpPrev[gp.index][key]=isActive;
      }
    }
  }
  setInterval(pollGamepads, 8);

  // Keyboard
  document.addEventListener("keydown", e=>{
    if(e.repeat) return;
    if(e.key==="f"||e.key==="F"||e.key==="j"||e.key==="J"||e.key===" "){
      triggerHit();
    }
  });

  // Canvas tap (works in READY + GAME; end page also works)
  canvas.addEventListener("pointerdown", e=>{
    if(isReadyScreen || isEndScreen){
      triggerHit();
      return;
    }
    if(!running) return;
    const r=canvas.getBoundingClientRect();
    const x=e.clientX-r.left, y=e.clientY-r.top;
    drumFlash=0.18;
    hitTestXY(x,y);
    playDrum().catch(()=>{});
  });

  // START button => goes to READY screen (not straight game)
  startBtn.addEventListener("click", async()=>{
    await unlockAudio();
    if(drumGain) drumGain.gain.value=drumVol;
    if(musicGain) musicGain.gain.value=musicVol;
    await goFullscreen(); resize();
    hideMenu();
    showReadyScreen();
  });

})();
</script>
</body>
</html>
